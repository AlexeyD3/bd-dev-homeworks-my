# Домашнее задание к занятию 6. «Troubleshooting»

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести эту операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя;

> Определим `opid` операции с помощью команд  `$currentOp` или `db.currentOp()` и затем завершим её командой `db.killOp(opid)`

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.

> Можно попробовать реализовать ограничение по медленным запросам для разных запросов используя `maxTimeMS`

> Либо включить `Database Profiler` и настроить фильтры для параметра `db.setProfilingLevel()`. Далее написать скрипт, который читал бы opid долгих операций из файла и завершал их. В скрипте предусмотреть исключения для завершения операций, для которых долгое выполнение является нормой, а так же запретить завершение операций, которые не были инициализированны пользователем (системные операции).

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:

- сначала происходит рост отношения записанных значений к истекшим,
- Redis блокирует операции записи.

Как вы думаете, в чём может быть проблема?
 
> Т.к. истекшие ключи не сразу удаляются, а хранятся в системе и очищаются одним из выбранных в настройках Redis условием, то может возникнуть такая ситуация в которой количество истёкших ключей за единицу времени, превышает количество истекших ключей, которые Redis успевает утилизировать. При этом Redis вновь и вновь пытается достигнуть порога (например < 25%) от количества неиспользуемых ключей и попадает в цикл, при этом в силу однопоточности - все иные операции блокируются.  
> Думаю в данном случае Redis удаляет истекшие ключи по условию "Delete regularly" и нужно либо изменить значение отвечающие за частоту проверок и объём удаляемых ключей (что даст дополнительную нагрузку на ЦП, но решит проблему блокировки со стороны Redis), либо выбрать стратегию "Timed deletion", которая занимает больше процессорного времени. Либо стратегию "lazy", которая удаляет истекшие ключи только во время повторного обращения к ним, но данная стратегия потребляет очень много памяти.

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

> Рост нагрузки привел к бОльшему потреблению ресурсов

Какие пути решения этой проблемы вы можете предложить?

> Первым делом проверим статус и доступность сервера.  
> Изучить данные мониторинга касающиеся производительности, возможно серверу нехватает таких ресурсов как память или ЦПУ.  
> Проверить и при необходимости увеличить парметры `max_allowed_packet` `wait_timeout` `max_connections` `connect_timeout` `interactive_timeout` `net_read_timeout`.  
> Через EXPLAIN изучить запрос принять решение о дальнейших действиях, например: оптимизации (изменения или разбиения) запроса, выставления `LIMIT` по возвращаемому запросу, применении кэширования запроса или резуьтата, шардирования таблицы.  
> Если проблема постоянная, то проверить целостность таблицы, которая вызывает проблему (например с помощью `myisamchk`).  



## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объёмом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили эту проблему?

> Системе не хватает ОЗУ, oom-killer пытается недопустить аварийного завершения системы и убивает самые "прожорливые" в плане ОЗУ процессы.  
> Со стороны Posеgres нужно провести настройку параметров `shared_buffers` `hash_mem_multiplier` `work_mem` и других, описаных в офф документации, эти параметры настраиваются исходя из доступных аппаратных ресурсов в каждом конкретном случае.
> Если указанные выше настройки уже были произведены можно увеличить количество оперативной памяти в системе (либо масштабировать систему горизонтально) или воспользоваться пуллером `PG Bouncer`. 
> Со стороны системы проверить настройки `vm.overcommit_memory` и `overcommit_ratio`, но вмешиваться в работу oom-killer'a не рекомендуется.


---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---

